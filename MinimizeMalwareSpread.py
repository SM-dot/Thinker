# Leetcode Link: https://leetcode.com/problems/minimize-malware-spread/description/
# Category: Graphs, DFS, BFS, DSU(optional but most optimised) 
'''
    so you would have a list of nodes for each components -> get through DSU
    For example 
    0 - [0, 1, 2, 3]
    1 - [4, 5, 6]
    2 - [9, 10, 11, 1]
    Infected nodes = [0, 1]
    remove exactly 1 node so we want to remove from that component which has exactly 1 infected node, if multiple infected nodes then no point removing one
    and to maximize non-infected nodes remove this from the largest component. 

    So have an array that keeps track of how many infected nodes are in it, size of the component and the the node with the smallest index

    1. Find the number of connected componets 
    2. identify connected component with only 1 infected node
    3. Choose the biggest connected component from 2 

    Here using a DSU rank by size would be best and reduce one step of finding the size. 

    Now let's code! 

'''
class DSU: 
    def __init__(self, n):
        self.parents = [i for i in range(n)]
        self.size = [1 for i in range(n)]
    
    def find(self, i):
        if i == self.parents[i]:
            return i
        
        self.parents[i] = self.find(self.parents[i])
        return self.parents[i]
    
    def union(self, x, y):
        x_parent = self.find(x)
        y_parent = self.find(y)

        if x_parent == y_parent:
            return 
        
        if self.size[x_parent] > self.size[y_parent]:
            self.parents[y_parent] = x_parent
            self.size[x_parent] += self.size[y_parent]
        else:
            self.parents[x_parent] = y_parent
            self.size[y_parent] += self.size[x_parent]
    
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        dsu = DSU(n)

        initial.sort()

        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1:
                    dsu.union(i, j)
        
        infectedNodesInComponent = defaultdict(int)
        minNode = float('inf')
        for infected in initial:
            infectedParent = dsu.find(infected)
            infectedNodesInComponent[infectedParent] += 1
        
        max_components = -1 
        ans  = -1
        for infected in initial: 
            infectedParent = dsu.find(infected)
            if infectedNodesInComponent[infectedParent] == 1:
                if dsu.size[infectedParent] > max_components:
                    max_components = dsu.size[infectedParent]
                    ans = infected 
        return ans if ans != -1 else min(initial)


